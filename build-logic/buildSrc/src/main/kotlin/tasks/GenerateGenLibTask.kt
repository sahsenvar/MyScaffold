package tasks

import extensions.applyIfNot
import extensions.require
import org.gradle.api.DefaultTask
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.File
import kotlin.collections.forEach
import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.InvocationKind
import kotlin.contracts.contract

abstract class GenerateGenLibTask : DefaultTask() {

    init {
        group = "genlib"
        description = "This task read version.toml file that denoted in path and generate an genlib object to access libs and plugins from composite build modules."
        versionCatalogFile.convention(project.layout.projectDirectory.file("../../gradle/libs.versions.toml"))
    }

    @get:InputFile
    abstract val versionCatalogFile: RegularFileProperty

    @OutputDirectory
    val outputFile = File(project.rootDir, "build/generated/")

    @TaskAction
    fun generate() {
        val sectionSet = Section.values().map { it.sectionName }.toSet()
        val tagsMap = sectionSet.associateWith { emptyMap<String, String>() }.toMutableMap()
        var lastSection: String = ""

        versionCatalogFile.get().asFile
            .require((File::exists)) { "Version catalog couldn't find: $absolutePath" }
            .applyIfNot(File::canRead) { setReadable(true) }
            .runCatching(File::readLines)
            .onFailure { error("Version catalog couldn't read $it") }
            .getOrThrow()
            .map { line ->
                line.replace(" ", "") // remove all spaces in line
                    .replace("\"", "") // remove all " characters in line
                    .substringBefore('#') // remove comments in line
            }
            .filterNot(String::isBlank) // remove all empty lines
            .mapNotNull { cleanLine -> // list of pairs as section
                if (cleanLine in sectionSet) {
                    lastSection = cleanLine
                    null
                } else if (cleanLine.startsWith("[")) // skip other sections like [metadata]
                    null
                else (lastSection to cleanLine)
            }
            .groupBy((Pair<String, String>::first), (Pair<String, String>::second))
            .forEach { (section, lines) ->
                tagsMap[section] = when (section) {
                    Section.Version.sectionName -> handleVersion(lines)
                    Section.Library.sectionName -> handleLibrary(lines)
                    Section.Plugin.sectionName -> handlePlugin(lines)
                    Section.Bundle.sectionName -> emptyMap()
                    else -> error("wtf!? section: $section")
                }
            }

        val versionKtContent = buildString {
            appendLine("// Generated by GenerateGenLibTask")
            appendLine("@file:Suppress(\"unused\", \"ClassName\", \"propertyName\", \"constPropertyName\")\n")
            appendLine("package com.sahsenvar.genlib")
            appendLine()
            appendLine("object genlibs {")

            // VERSIONS
            appendLine("\tobject Versions{")
            tagsMap[Section.Version.sectionName]?.forEach { (versionName, versionValue) ->
                appendLine(
                    "\t\tconst val ${versionName.replace('-', '_')} = \"$versionValue\""
                )
            }
            appendLine("\t}\n")

            // PLUGINS
            appendLine("\tobject plugins {")
            tagsMap[Section.Plugin.sectionName]?.forEach { (pluginName, pluginValue) ->
                appendLine(
                    "\t\tconst val ${pluginName.replace('-', '_')} = \"$pluginValue\""
                )
            }
            appendLine("\t}\n")

            //LIBRARIES
            tagsMap[Section.Library.sectionName]?.forEach { (libName, libValue) ->
                appendLine(
                    "\tconst val ${libName.replace('-', '_')} = \"$libValue\""
                )
            }
            appendLine("}")
        }

        // Generation
        File(outputFile, "Genlib.kt")
            .applyIfNot(File::canWrite) { setWritable(true) }
            .apply {
                writeText(versionKtContent)
                setWritable(false)
                println("Genlib.kt Ã¼retildi: $absolutePath")
            }
    }

    private fun handleVersion(lines: List<String>): Map<String, String> {
        return lines.map { line -> line.split("=", limit = 2).let { it.first() to it.last() } }
            .associate { it.first to it.second }
    }

    private fun handleLibrary(lines: List<String>): Map<String, String> {
        return lines.map { line -> // "androidx-material3={group=androidx.compose.material3,name=material3,version.ref=composeM3}"
            line.split("=", limit = 2)
                .let { it.first() to it.last() } // {"androidx-material3" = "{group=androidx.compose.material3,name=material3,version.ref=composeM3}"}
        }.associate { (key, value) ->
            value.dropSurrounding() // "group=androidx.compose.material3,name=material3,version.ref="composeM3"
                .split(",") // ["group=androidx.compose.material3", "name=material3", "version.ref=composeM3"]]
                .apply { if (size == 1) return mapOf(key to first()) }
                .flatMap { it.split("=") } // ["group", "androidx.compose.material3", "name", "material3", "version.ref", "composeM3"]
                .chunked(2)// [["group", "androidx.compose.material3"], ["name", "material3"], ["version.ref", "composeM3"]]
                .associate { it.first() to it.last() } // {"group" = "androidx.compose.material3", "name" = "material3, "version.ref" = "composeM3"}
                .let { map ->
                    val p1 = (map["group"] ?: map["module"]) + ':' // androidx.compose.material3
                    val p2 = (map["name"] ?: "") // material3
                    val p3 = (map["version"]
                        ?: map["version.ref"]
                            ?.prefix("\${Versions.")
                            ?.plus("}"))
                        ?.prefix(":")
                        ?: "" // $composeM3
                    key to (p1 + p2 + p3)// {"androidx-material3"="androidx.compose.material3:material3:$composeM3"}
                }
        }
    }

    private fun handlePlugin(lines: List<String>): Map<String, String> {
        return lines.map { line -> // "android-application={id=com.android.application,version.ref=agp}"
            line.split("=", limit = 2)
                .let { it.first() to it.last() } // {"android-application" to "{id=com.android.application,version.ref=agp}"}
        }.associate { (key, value) ->
            value.dropSurrounding() // "id=com.android.application,version.ref=agp"
                .split(",") // ["id=com.android.application", "version.ref=agp"]
                .flatMap { it.split("=") } // ["id", "com.android.application", "version.ref", "agp"]
                .chunked(2) // [["id", "com.android.application"], ["version.ref", "agp"]]
                .associate { it.first() to it.last() } // {"id"="com.android.application", "version.ref"="agp"}
                .let { map ->
                    key to (map["id"] ?: map["module"] ?: "")
                } // {"android-application"="com.android.application"}

        }
    }
}

private fun String.dropSurrounding(): String =
    if (this.length <= 2) "" else this.substring(1, this.length - 1)

private fun String.prefix(prefix: String): String {
    return prefix + this
}